# 1.Algorithm



### QUESTION:

Given a singly linked list, determine if it is a palindrome.

**Example 1:**

```
Input: 1->2
Output: false
```

**Example 2:**

```
Input: 1->2->2->1
Output: true
```

**Follow up:**
Could you do it in O(n) time and O(1) space?





### SOLUTION 1: 



```java
	
 	/**
     * 利用解耦思想，先找出中点，再截取后半段进行链表反转，最后与原链表进行比较
     *
     * @param head
     * @return 
     */
	public  boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) {
            return true;
        }

        ListNode origin = head;

        ListNode middle = findMiddle(head);
        middle.next = reverseListNodeDie(middle.next);

        ListNode pre = origin;
        ListNode nex = middle.next;
        while (nex != null && pre != null && nex.val == pre.val) {
            pre = pre.next;
            nex = nex.next;
        }
        return nex == null;
    }

    /**
     * 快慢指针寻找中间节点
     *
     * @param head
     * @return
     */
    public  ListNode findMiddle(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode min = head;
        ListNode max = head.next; // 这里注意要先区分开min max ，不然【1,2】这种情况会走两次while，造成中点变成2
        while (max != null && max.next != null) {
            min = min.next;
            max = max.next.next;
        }
        return min;
    }

    /**
     * 迭代反转链表
     *
     * @param origin
     * @return
     */
    public  ListNode reverseListNodeDie(ListNode origin) {
        if (origin == null) {
            return origin;
        }
        ListNode preNode = null;
        ListNode nextNode = null;
        ListNode nowNode = origin;
        while (nowNode != null) {
            nextNode = nowNode.next;
            nowNode.next = preNode;
            preNode = nowNode;
            nowNode = nextNode;
        }
        return preNode;
    }

```





# 2.Review



# 3.Tip	



# 4.Share

​	





