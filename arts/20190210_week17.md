# 1.Algorithm



### QUESTION:

Given a singly linked list, determine if it is a palindrome.

**Example 1:**

```
Input: 1->2
Output: false
```

**Example 2:**

```
Input: 1->2->2->1
Output: true
```

**Follow up:**
Could you do it in O(n) time and O(1) space?





### SOLUTION 1: 



```java
	
 	/**
     * 利用解耦思想，先找出中点，再截取后半段进行链表反转，最后与原链表进行比较
     *
     * @param head
     * @return 
     */
	public  boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) {
            return true;
        }

        ListNode origin = head;

        ListNode middle = findMiddle(head);
        middle.next = reverseListNodeDie(middle.next);

        ListNode pre = origin;
        ListNode nex = middle.next;
        while (nex != null && pre != null && nex.val == pre.val) {
            pre = pre.next;
            nex = nex.next;
        }
        return nex == null;
    }

    /**
     * 快慢指针寻找中间节点
     *
     * @param head
     * @return
     */
    public  ListNode findMiddle(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode min = head;
        ListNode max = head.next; // 这里注意要先区分开min max ，不然【1,2】这种情况会走两次while，造成中点变成2
        while (max != null && max.next != null) {
            min = min.next;
            max = max.next.next;
        }
        return min;
    }

    /**
     * 迭代反转链表
     *
     * @param origin
     * @return
     */
    public  ListNode reverseListNodeDie(ListNode origin) {
        if (origin == null) {
            return origin;
        }
        ListNode preNode = null;
        ListNode nextNode = null;
        ListNode nowNode = origin;
        while (nowNode != null) {
            nextNode = nowNode.next;
            nowNode.next = preNode;
            preNode = nowNode;
            nowNode = nextNode;
        }
        return preNode;
    }

```





# 2.Review

本周分享[towardsdatascience.com]()  docker系列文章之二

[Learn Enough Docker to be Useful      Part 2: A Delicious Dozen Docker Terms You Need to Know](https://towardsdatascience.com/learn-enough-docker-to-be-useful-1c40ea269fa8)



在上一篇文章，作者介绍了docker的一些概念性定义，以及运用一些类比的手法，帮助读者更加有效地理解docker是什么，docker要做什么，这样做有些什么好处。



本文中，作者着重介绍Docker的生态地位

​	作者将Docker 分为 两大部分   

​	***Essentials*** and ***Scaling***



**1.Docker Essentials**      即Docker 基础必要组成部分，他们分别是 ：

- [**Docker Platform**](https://docs.docker.com/engine/docker-overview/#the-docker-platform)    the software that makes Docker containers possible
- [**Docker Engine**](https://www.docker.com/products/docker-engine)       client-server app (CE or Enterprise)
- [**Docker Client**](https://docs.docker.com/engine/docker-overview/)          handles Docker CLI so you can communicate with the Daemon
- [**Docker Daemon**](https://docs.docker.com/engine/docker-overview/)     Docker server that manages key things
- [**Docker Volumes**](https://docs.docker.com/storage/volumes/)     persistent data storage
- [**Docker Registry**](https://hub.docker.com/)       remote image storage
- [**Docker Hub**](https://hub.docker.com/)              default and largest Docker Registry
- [**Docker Repository**](https://docs.docker.com/docker-hub/repos/)   collection of Docker images, e.g. Alpine

​	

**2.Scaling Docker**  即Docker 标准化

- [**Docker Networking**](https://docs.docker.com/engine/tutorials/networkingcontainers/)            connect containers together
- [**Docker Compose**](https://docs.docker.com/compose/)               time saver for multi-container apps
- [**Docker Swarm**](https://docs.docker.com/engine/swarm/)                 orchestrates container deployment
- [**Docker Services**](https://docs.docker.com/get-started/part3/#introduction)           containers in production

[**Kubernetes**](https://kubernetes.io/)   是一款自动的 容器发布，伸缩，管理的容器化应用。也称k8s  显然，它在如今的容器编排市场已经毫无悬念地成为了赢家。 人们更倾向于使用K8s来对应用记性多容器伸缩，而不是Docker Swarm/

下一篇文章将会介绍Dockerfile

# 3.Tip	



# 4.Share

​	





