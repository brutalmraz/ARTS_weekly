# 1.Algorithm



Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

**Example:**

```
Input: 1->2->4, 1->3->4
Output: 1->1->2->3->4->4
```



```java
public class MergeTwoList {

    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode head = null;
        if (l1 == null) {
            return l2;
        }
        if (l2 == null) {
            return l1;
        }
        if (l1.val <= l2.val) {
            head = l1;
            l1 = l1.next;
        } else {
            head = l2;
            l2 = l2.next;
        }

        ListNode tmp = head;
        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                tmp.next = l1;
                l1 = l1.next;
            } else {
                tmp.next = l2;
                l2 = l2.next;
            }
            tmp = tmp.next;
        }

        if (l1 == null) {
            tmp.next = l2;
        }
        if (l2 == null) {
            tmp.next = l1;
        }

        return head;
    }
}

```

# 2.Review

[Learn Enough Docker to be Useful](https://towardsdatascience.com/learn-enough-docker-to-be-useful-b7ba70caeb4b)	

今天Review的是towardsdatascience.com 上的一篇关于Docker的 概念性入门文章. 

<首先,容器技术的迅猛发展对软件开发和数据科学起到了相当积极的作用,它让后者的安全性/再生性/扩展性得到了极大的提升.>  作者对容器技术的评价还是蛮高的. 作者认为以docker为代表的容器技术就是今后软件开发和数据科学的未来.

作者在文中提到,接下来还会有五篇文章, 分别从Docker terms, Dockerfiles, Docker images, Docker commands, and data storage 来对docker进行一个系统性的介绍.  而本篇文章则是概念性的引入.

我们在认识一个抽象事物的时候, 常常会运用隐喻的方法. 对于docker容器, 我们也可以这样理解. 



### 容器

我们姑且就把docker看做是一个塑料箱子, 那么这个塑料箱子具有哪些特征呢?

1. 装东西 (容纳文件) .    容器内部能容纳我们想要存放的东西
2. 可以移动 (可以被拷贝) .   我们作为箱子的使用者, 可以把箱子搬来搬去, 同时由于隔离性好, 箱子里面的东西不会因为我们的搬动,而逃出来.
3. 有口子让我们打开(有给定的访问权限)  .  箱子不可能是完全密封的,我们必须可以从箱子里面取出或者放入东西,来迎合我们自己的使用需求.  否则, 箱子的实用性会大打折扣  . 同时我们可以通过打开箱子门 对箱子内部的东西进行触摸.
4. 可以在远端获取 .   亚马逊的塑料盒子是从供应商那儿获取的磨具统一压制出来的.    (同样, docker容器技术有一种叫做镜像的东西, 类似于磨具, 你可以获取到这些磨具 然后把它们制造成docker容器.)

### 生命

我们也可以把docker容器看作是一个生命, 运行着的docker容器终有死亡(shutdown)的那一天.  

docker容器某种程度上就是被赋予生命后的镜像.



### 程序

docker容器是一个程序,  当它运行的时候, 其他程序也可以在这个程序内部运行.

就像其他任何普通程序一样,docker程序可以被创建 运行 检查 停止 删除



### 几个概念

- 关于虚拟机    

  ​	虚拟机的概念要比容器更早出现,但是docker 资源消耗少,移动便捷性和性能表现在大多数时候都优于虚拟机

  ​	这里有一篇文章对他们做了详细的对比

  ​	[A Beginner-Friendly Introduction to Containers, VMs and Docker](https://medium.freecodecamp.org/a-beginner-friendly-introduction-to-containers-vms-and-docker-79a9e3e119b)

- docker镜像

  ​	它就像一张照片, 一个模具, 你可以用他快速搭建起一个容器 . An image contains the Dockerfile, libraries, and code your application needs to run, all bundled together.

- Dockerfile

  ​	dockerfile 就像是构建docker容器的说明书.它表述了 通过何种方式, 在何时何地, 构建一个怎样的容器.   					  dockerfile基于一个初始化镜像层,来开始构建容器, 比较流行的基础镜像包括python,Ubuntu,alpine .

  ​	其他可选附加层会被添加到基础层的上层.

  ​	总的来讲,根据dockerfile, 我们可以将轻量级的可写镜像层不断地添加到之前的镜像基础上. 层层迭进.

- 一系列比喻

  假设我们要进行一次烹饪

  docker平台就像是锅炉, dockerfile是菜单, 告诉我们如何烹饪(里面有列出食材,烹饪方法,其他道具),  docker镜像层就是食材,  食材不可能是单一的, 我们随时需要在一个食材的基础上不断地加东西   

  创建好的docker容器就像是烹饪完成的pizza,而在容器中运行你的APP 就像是 在吃pizza . 这个类比非常的微妙.



可以说, 这是一篇比较形象的docker概念入门文章, 主要用了类比的手法, 帮助我们了解抽象事物.

# 3.Tip	

本周分享一下容错的基础概念.

**为什么需要容错限流？**

随着现代互联网企业技术的高速发展， 传统单体应用已经不再能适应当今技术圈的发展潮流，近年来，随着微服务技术的大行其道，可以说已经在技术圈内掀起了一股不小的微服务浪潮，甚至连部分传统软件开发商都开始着手微服务技术的更迭改造。

随着微服务化的不断深入， 人们逐渐发现了从单体应用拆分到多个微服务之后， 系统的可用性也在发生着改变。假设某单体服务的可用性为99.99%  那么30个微服务的理论可用性大约就是99.99%的三十次方，即99.70% .在一个高度复杂的分布式系统中通常有很多依赖， 如果一个单一应用不能对其他依赖故障进行隔离的话， 最后就会因为个体的故障(崩溃或是高峰期延迟)而影响到系统全局， 牵一发动全身。严重的时候会影响到系统资源的雪崩。 



容错处理的主要手段:

1. **主动超时**

2. **限流    （限制最大并发数）**

3. **熔断  （错误数达到阈值 类似于保险丝熔断）**

4. **隔离**  舱壁隔离模式   失败单元不影响整体

5. **降级** 

   

**容错理念**

- 凡是依赖都有可能失败
- 凡是资源都有限制 CPU、Memory、Threads, Queue
- 网络并不可靠
- 延迟是稳定性的杀手

**弹性理念**

- 在被弯曲 压缩 拉伸后，能够恢复原状的能力



断路器最著名的实现就是Hytrix ,出自Netflix公司

Hytrix 的原理基于滑动窗口理论。 滑动窗口包含10个桶。每个桶时间宽度为1秒， 记录了总请求数， 失败次数， 超时次数，线程拒绝次数。新的1秒来临时， 丢弃最旧的一个桶。所以称为滑动窗口。

断路器的三大状态：

- **关闭closed** (服务正常时)
- **半开启 half open** （断路器开启后的某个时间后，向服务发起探测，成功就关闭，不成功就继续开启）
- **开启open**（服务调用失败次数达到阈值后）





降级策略

- Fail Fast :快速失败   直接throw Exception
- Fail Silent : 安静失败  返回空置 或者空集合 空Map等
- Static Fallback :   返回缺省值
- Fallback via Network :  通过辅助服务的网络来决定
- Primary and Secondary with Fallbak : 新功能老功能切换

两个特殊场景

- 请求合并 (缓解压力, 打包小请求 batch,统一请求服务端,   响应回来后, 进行拆解处理,   这就减轻了后台的压力 )   
- 请求缓存 (请求频繁但返回数据在一定时间内都是一样的) , 可以做缓存刷新



**信号量隔离和线程隔离**



线程隔离: 为每个依赖的服务都单独创造一个线程池进行隔离

优点: 支持排队和超时 支持异步调用

缺点: 线程调用的额外开销

适用 : 不受信客户  有限扇出



信号量隔离:  对于每个依赖都单独设定一个信号量, 超过则不再受理 . 可以理解成简单的计数器

优点: 轻量级 简单  

缺点: 不支持异步调用  不支持任务排队和主动超市

适用于受信客户  高扇出  高频高速调用

# 4.Share

​	本周分享一篇Fenng大的文章:

[如何成为一个心智成熟的人](https://mp.weixin.qq.com/s/lOEMrVCbdmpmZVA-I_7CfA)

这篇文章非常能引起我的「共鸣」, 其实我在工作生活中虽然平时还是比较温和的,  但往往会因为就事论事或者做事心切而情绪化, 甚至将情绪迁怒于别人, 说出一些不入耳的话,  这是心智不成熟的表现. 

很多时候,在一些问题上,想要立刻分个是非对错，这件事我明明对了，凭什么说我是错的，让我来背这黑锅呢。 后来，仔细想想，自己的确还是缺乏反省。

如果自己做的对，那么以后有的是机会证明自己，为何要争一时之快呢？如果自己做的不对， 那么是不是对自己和他人的认知有偏差呢？  是不是经常出现这样的偏差呢？

工作之后，自己确实缺乏一些自省能力， 没有系统总结自己哪方面做得好， 哪方面做的差， 以至于很难发现自己的特点和道路。  	缺乏持续做事的稳定性，虽然最近有改善， 但是远远不够， 就拿ARTS这件事来讲，就没有坚持到每周更新， 总是给自己找各种理由，生活的，工作的，反正总有理由。  	在注意力管控上也有所欠缺，看书的时候总习惯偶尔翻翻微信微博。   这些无疑都是陋习，非常致命。  

Fenng厉害的地方就在于，他能从一个较为刻薄甚至情绪管理比较糟糕的人完成如此巨大的蜕变， 虽然这个蜕变并不完全。   他善于自省，勤于吸收，并努力践行。  之前看到过Fenng大有发表一些争议的言论 招来微博和知乎的一致抵制和辱骂。   但是，就像他说的那样： 我已经走远，你还在原地。

好好打磨心智吧。   自省，吸收，践行！ 





